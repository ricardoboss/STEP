using Spectre.Console.Rendering;
using StepLang.CLI.Extensions;
using StepLang.Tokenizing;
using StepLang.Tooling.Analysis;
using StepLang.Tooling.Highlighting;
using System.Globalization;
using Style = Spectre.Console.Style;

namespace StepLang.CLI.Widgets;

internal sealed class Code : IRenderable
{
	private const int LineNumberPaddingWidth = 1;
	private const int LineNumberSeparatorWidth = 1;
	private const string AsciiLineNumberSeparator = "|";
	private const string UnicodeLineNumberSeparator = "\u2502";

	private const int PaddingWidth = 1;

	private const int LineMarkerWidth = 1;
	private const string AsciiLineMarker = ">";
	private const string UnicodeLineMarker = "\u25B6";

	private const string AsciiColumnMarker = "^";
	private const string UnicodeColumnMarker = "\u25B2";

	private const string AsciiUnderline = "-";
	private const string UnicodeUnderline = "\u2500";

	private const string TabReplacement = "    ";

	private readonly string code;
	private readonly bool showLineNumbers;
	private readonly int lineNumberOffset;
	private readonly int? markedLineNumber;
	private readonly int? markedColumnNumber;
	private readonly int? markedColumnCount;
	private readonly ColorScheme scheme;

	private List<string>? lines;
	private List<string> Lines => lines ??= code.SplitLines().ToList();

	public Code(string code, ColorScheme scheme, bool showLineNumbers = true, int lineNumberOffset = 0,
		int? markedLineNumber = null, int? markedColumnNumber = null, int? markedColumnCount = null)
	{
		if (lineNumberOffset < 0)
		{
			throw new ArgumentOutOfRangeException(nameof(lineNumberOffset), "Line number offset cannot be negative.");
		}

		this.code = code;
		this.showLineNumbers = showLineNumbers;
		this.scheme = scheme;
		this.lineNumberOffset = lineNumberOffset;
		this.markedLineNumber = markedLineNumber;
		this.markedColumnNumber = markedColumnNumber;
		this.markedColumnCount = markedColumnCount;
	}

	public Measurement Measure(RenderOptions options, int maxWidth)
	{
		var max = Lines.Select(l => l.Replace("\t", TabReplacement)).Max(l => l.Length);

		if (showLineNumbers)
		{
			var lineNumberWidth = (lineNumberOffset + Lines.Count).ToString(CultureInfo.InvariantCulture).Length;

			max += lineNumberWidth + LineNumberPaddingWidth + LineNumberSeparatorWidth + LineNumberPaddingWidth;
		}

		if (markedLineNumber is not null)
		{
			max += LineMarkerWidth + PaddingWidth;
		}

		return new Measurement(max, max);
	}

	public IEnumerable<Segment> Render(RenderOptions options, int maxWidth)
	{
		var highlighter = new Highlighter(scheme);
		var highlighted = highlighter.Highlight(code).ToList();

		var currentLineNumber = lineNumberOffset;
		var lastLineNumber = currentLineNumber + highlighted.Count;
		var lastLineNumberWidth = lastLineNumber.ToString(CultureInfo.InvariantCulture).Length;

		var defaultStyle = scheme.Default.ToSpectreStyle();
		var markerStyle = Style.Parse("red");

		var lineNumberSeparator = options.Unicode ? UnicodeLineNumberSeparator : AsciiLineNumberSeparator;
		var lineMarker = options.Unicode ? UnicodeLineMarker : AsciiLineMarker;
		var columnMarker = options.Unicode ? UnicodeColumnMarker : AsciiColumnMarker;
		var underline = options.Unicode ? UnicodeUnderline : AsciiUnderline;

		using var enumerator = highlighted.GetEnumerator();
		while (enumerator.MoveNext())
		{
			currentLineNumber++;

			if (markedLineNumber is not null)
			{
				if (markedLineNumber == currentLineNumber)
				{
					yield return new Segment(lineMarker, markerStyle);
				}
				else
				{
					yield return new Segment(new string(' ', LineMarkerWidth), defaultStyle);
				}

				yield return new Segment(new string(' ', PaddingWidth), defaultStyle);
			}

			if (showLineNumbers)
			{
				yield return new Segment(
					currentLineNumber.ToString(CultureInfo.InvariantCulture).PadLeft(lastLineNumberWidth),
					defaultStyle);

				yield return new Segment(new string(' ', PaddingWidth), defaultStyle);
				yield return new Segment(lineNumberSeparator, defaultStyle);
				yield return new Segment(new string(' ', PaddingWidth), defaultStyle);
			}

			var currentLineTabCount = 0;
			while (enumerator.Current is not null && enumerator.Current.Type != TokenType.NewLine)
			{
				currentLineTabCount += enumerator.Current.Text.Count(c => c == '\t');

				yield return new Segment(enumerator.Current.Text.Replace("\t", TabReplacement),
					enumerator.Current.Style.ToSpectreStyle());

				_ = enumerator.MoveNext();
			}

			if (markedLineNumber == currentLineNumber && markedColumnNumber is not null)
			{
				yield return Segment.LineBreak;

				var column = markedColumnNumber.Value;
				var markerOffset = column - 1;
				for (var i = 0; i < currentLineTabCount; i++)
				{
					markerOffset += 3;
				}

				yield return new Segment(new string(' ', LineMarkerWidth + PaddingWidth), defaultStyle);

				if (showLineNumbers)
				{
					yield return new Segment(new string(' ', lastLineNumberWidth + PaddingWidth), defaultStyle);
					yield return new Segment(lineNumberSeparator, defaultStyle);
					yield return new Segment(new string(' ', PaddingWidth), defaultStyle);
				}

				yield return new Segment(new string(' ', markerOffset), markerStyle);
				yield return new Segment(columnMarker, markerStyle);

				if (markedColumnCount is > 1)
				{
					for (var i = 0; i < markedColumnCount - 1; i++)
					{
						yield return new Segment(underline, markerStyle);
					}
				}
			}

			yield return Segment.LineBreak;
		}
	}
}
